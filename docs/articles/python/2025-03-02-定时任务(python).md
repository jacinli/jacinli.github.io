# ç›®å½•

[[toc]]

## ä»‹ç»

**ğŸ§© ä»€ä¹ˆæ˜¯â€œå®šæ—¶ä»»åŠ¡â€ï¼Ÿ**

å®šæ—¶ä»»åŠ¡ï¼Œå°±æ˜¯**æŒ‰ç…§è®¾å®šçš„æ—¶é—´é—´éš”æˆ–æ—¶é—´ç‚¹è‡ªåŠ¨æ‰§è¡ŒæŸäº›æ“ä½œ**ã€‚æ¯”å¦‚ï¼š

```
â€¢	æ¯å¤©æ—©ä¸Š8ç‚¹å‘é€šçŸ¥
â€¢	æ¯éš”10ç§’é‡‡é›†ä¸€æ¬¡æ•°æ®
â€¢	æ¯å°æ—¶æ¸…ç†ä¸€æ¬¡ç¼“å­˜

```

## ç›¸å…³ä½¿ç”¨

**âœ… æœ€ç®€å•çš„æ–¹å¼ï¼šwhile True + time.sleep()**

```python
import time

def job():
    print("æ‰§è¡Œä»»åŠ¡")

while True:
    job()
    time.sleep(10)  # æ¯10ç§’æ‰§è¡Œä¸€æ¬¡
```

**âœ… ä¼˜ç‚¹ï¼š**

â€¢	å†™æ³•ç®€å•ï¼Œä¸éœ€è¦ä»»ä½•ä¾èµ–

â€¢	æ§åˆ¶åŠ›å¼º

**âŒ ç¼ºç‚¹ï¼š**

â€¢	**ä¼šé˜»å¡å½“å‰çº¿ç¨‹**

â€¢	ç²¾åº¦å·®ï¼ˆä»»åŠ¡æ‰§è¡Œæ—¶é—´ä¼šå½±å“é—´éš”ï¼‰

â€¢	æ²¡æœ‰â€œç²¾ç¡®åˆ°å‡ ç‚¹å‡ åˆ†â€çš„è°ƒåº¦èƒ½åŠ›

**âœ… è¿›é˜¶æ–¹æ¡ˆï¼šä½¿ç”¨ schedule åº“**

```python
pip install schedule
```

```python
import schedule
import time

def job():
    print("æ¯éš”5ç§’æ‰§è¡Œä¸€æ¬¡")

schedule.every(5).seconds.do(job)

while True:
    schedule.run_pending()
    time.sleep(1)
    
    
>>>>>>>>>
schedule.every().day.at("10:30").do(job) æ¯å¤©10:30
schedule.every().monday.at("09:00").do(job) æ¯å‘¨ä¸€ä¸Šåˆ9ç‚¹
```

â€¢	schedule.run_pending() ä¼šæ£€æŸ¥ï¼š**æ˜¯å¦æœ‰ä»»åŠ¡åº”è¯¥æ‰§è¡Œ**

â€¢	å¦‚æœæ˜¯ï¼Œå°±æ‰§è¡Œå¯¹åº”çš„ job()

â€¢	ç„¶å time.sleep(1) è®©ä¸»çº¿ç¨‹ä¼‘æ¯ 1 ç§’ï¼Œå†å¾ªç¯æ£€æŸ¥

â± **æ‰€ä»¥ï¼šä»»åŠ¡æ˜¯æ¯5ç§’ä¸€æ¬¡ï¼Œä¸æ˜¯â€œä¼‘æ¯6ç§’â€ã€‚sleep(1) æ˜¯ç”¨äºâ€œè½®è¯¢æ£€æµ‹ä»»åŠ¡æ˜¯å¦è¯¥æ‰§è¡Œâ€ï¼Œå¹¶ä¸ä¼šå½±å“ä»»åŠ¡å‘¨æœŸæœ¬èº«ã€‚**

**âœ… ä¼˜ç‚¹ï¼š**

â€¢	è¯­æ³•ä¼˜é›…ã€ç®€å•

â€¢	æ”¯æŒ every().minutes, every().day.at("10:00") è¿™ç§å†™æ³•

â€¢	é€‚åˆå°å‹ä»»åŠ¡ç®¡ç†

**âœ… æ›´å¼ºå¤§çš„æ–¹æ¡ˆï¼šä½¿ç”¨ APScheduler**

```python
from apscheduler.schedulers.blocking import BlockingScheduler

def job():
    print("æ¯5ç§’æ‰§è¡Œä¸€æ¬¡")

scheduler = BlockingScheduler() # åˆ›å»ºä¸€ä¸ªé˜»å¡å‹è°ƒåº¦å™¨å®ä¾‹ 
scheduler.add_job(job, 'interval', seconds=5) # æ¯éš”5ç§’è°ƒåº¦ä¸€æ¬¡ job å‡½æ•°
scheduler.start()  # å¯åŠ¨è°ƒåº¦å™¨ï¼ˆè¿™ä¸ªä¼šé˜»å¡ä¸»çº¿ç¨‹ï¼‰
```

å†…éƒ¨åŸç†ç¡®å® **æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªâ€œå®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨ + ä»»åŠ¡è½®è¯¢å™¨â€**ã€‚

APScheduler æä¾›äº†å¤šç§è°ƒåº¦å™¨ï¼Œæ¯”å¦‚ï¼š

â€¢	BlockingScheduler: å¯åŠ¨åä¼š**é˜»å¡ä¸»çº¿ç¨‹**ï¼Œé€‚åˆç®€å•è„šæœ¬

â€¢	BackgroundScheduler: åœ¨åå°å¯åŠ¨ï¼Œä¸é˜»å¡ä¸»çº¿ç¨‹

â€¢	AsyncIOScheduler, TornadoScheduler, TwistedScheduler: åˆ†åˆ«é€‚é…ä¸åŒå¼‚æ­¥æ¡†æ¶

| **ç±»å‹** | **å«ä¹‰** |
| --- | --- |
| interval | å›ºå®šæ—¶é—´é—´éš” |
| cron | ç±»ä¼¼ crontab è¡¨è¾¾å¼ï¼Œæ”¯æŒç²¾ç¡®åˆ°ç§’ |
| date | åªè¿è¡Œä¸€æ¬¡ï¼ŒæŒ‡å®šæ—¶é—´ç‚¹ |

è°ƒç”¨ start() åï¼Œå®ƒä¼šå¯åŠ¨ä¸€ä¸ªå†…éƒ¨çš„ **å¾ªç¯è°ƒåº¦çº¿ç¨‹**ï¼ˆæˆ–äº‹ä»¶å¾ªç¯ï¼‰ï¼š

â€¢	æŒç»­ç»´æŠ¤ä¸€ä¸ª **â€œä»»åŠ¡æ‰§è¡Œè®¡åˆ’è¡¨â€**ï¼ˆå†…éƒ¨æ˜¯ä¼˜å…ˆé˜Ÿåˆ—ï¼‰

â€¢	æ¯ä¸€è½® tickï¼ˆå¯èƒ½æ˜¯ 0.5~1 ç§’çº§åˆ«ï¼‰ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰ä»»åŠ¡åˆ°äº†æ‰§è¡Œæ—¶é—´

â€¢	æœ‰å°±æ‰§è¡Œï¼ˆç”¨çº¿ç¨‹æ± æˆ–è¿›ç¨‹æ± æ‰§è¡Œï¼‰

| **ç‰¹æ€§** | **è¯´æ˜** |
| --- | --- |
| æ”¯æŒå¤šç§è°ƒåº¦ç±»å‹ | interval / cron / date |
| æœ‰ä»»åŠ¡æ³¨å†Œä¸­å¿ƒ | ç®¡ç†æ‰€æœ‰å¾…è¿è¡Œçš„ä»»åŠ¡ |
| æœ‰æ—¶é—´è½®è¯¢æœºåˆ¶ | ç±»ä¼¼äº‹ä»¶å¾ªç¯ï¼Œå‘¨æœŸæ€§æ£€æŸ¥æ˜¯å¦â€œè§¦å‘â€ |
| å¯ä»¥å¹¶å‘æ‰§è¡Œ | é»˜è®¤ä½¿ç”¨çº¿ç¨‹æ±  |
| å¯æŒä¹…åŒ–ä»»åŠ¡ | æ”¯æŒ SQLiteã€Redis ç­‰å­˜å‚¨åæ¢å¤ |

## åŸºäºasyncio + è‡ªå®šä¹‰æ—¶é—´

**ä¼˜ç‚¹ï¼š**

â€¢	è‡ªç”±åº¦é«˜ï¼šå¯ä»¥çµæ´»è®¡ç®—ä¸‹ä¸€æ¬¡æ‰§è¡Œæ—¶é—´ã€‚

â€¢	æ— éœ€é¢å¤–ä¾èµ–ï¼ŒåŸç”Ÿ asyncio å°±èƒ½è·‘ã€‚

â€¢	è·Ÿ Redis ç»“åˆå¾ˆå¥½ï¼Œå¯ä»¥åšè·¨è¿›ç¨‹/è·¨æœºå™¨ä»»åŠ¡åè°ƒã€‚

**ç¼ºç‚¹ï¼š**

â€¢	æ‰‹åŠ¨ç®¡ç†å®šæ—¶é€»è¾‘ï¼ˆget_next_run_time + asyncio.sleep()ï¼‰ã€‚

â€¢	å¤šä»»åŠ¡å¯èƒ½ä¸å¥½ç®¡ç†ï¼Œæ¯”å¦‚æš‚åœ/é‡å¯æŸä¸ª jobã€‚

â€¢	ä¸æ”¯æŒ cron è¡¨è¾¾å¼ç­‰å¤æ‚è°ƒåº¦ã€‚

```python
import asyncio
import logging
import os
from datetime import datetime, timedelta

import redis.asyncio as redis

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ScheduleService:
    def __init__(self):
        self.redis_subscribe_key = "demo:subscription"
        self.exist_subscribe_key = "demo:exist_push"
        self.push_interval_seconds = 600  # æ¨é€é—´éš”æ—¶é—´
        self.fixed_times = ["08:00", "12:00", "18:00"]  # å›ºå®šè°ƒåº¦æ—¶é—´åˆ—è¡¨

    def get_next_run_time(self):
        now_time = datetime.now()
        today_str = now_time.strftime("%Y-%m-%d")
        
        # ä»Šæ—¥çš„æ‰€æœ‰è°ƒåº¦æ—¶é—´ç‚¹
        run_times = [datetime.strptime(f"{today_str} {t}", "%Y-%m-%d %H:%M") for t in self.fixed_times]
        future_times = [t for t in run_times if t > now_time]

        if future_times:
            return min(future_times)
        else:
            # å¦‚æœä»Šå¤©å·²ç»è¿‡äº†æ‰€æœ‰è°ƒåº¦æ—¶é—´ï¼Œåˆ™è¿”å›æ˜å¤©çš„ç¬¬ä¸€ä¸ªæ—¶é—´ç‚¹
            next_day = (now_time + timedelta(days=1)).strftime('%Y-%m-%d')
            return datetime.strptime(f"{next_day} {self.fixed_times[0]}", "%Y-%m-%d %H:%M")

    async def redis_client(self):
        return await redis.from_url("redis://localhost:6379", decode_responses=True)

    async def fixed_time_task(self):
        while True:
            next_run_time = self.get_next_run_time()
            sleep_seconds = max(1, (next_run_time - datetime.now()).total_seconds())
            logger.info(f"[å®šæ—¶ä»»åŠ¡] ä¸‹æ¬¡æ‰§è¡Œæ—¶é—´: {next_run_time}, sleep {sleep_seconds:.0f} ç§’")

            await asyncio.sleep(sleep_seconds)
            logger.info("[å®šæ—¶ä»»åŠ¡] æ‰§è¡Œå…·ä½“é€»è¾‘...âœ…")
            # TODO: æ·»åŠ ä½ è‡ªå·±çš„å®šæ—¶ä»»åŠ¡é€»è¾‘

    async def check_redis_and_push(self):
        while True:
            try:
                redis = await self.redis_client()
                now_score = int(datetime.now().strftime("%H%M"))
                trigger_score = now_score + 4

                subscriptions = await redis.zrangebyscore(
                    self.redis_subscribe_key, now_score, trigger_score, withscores=True
                )

                if subscriptions:
                    logger.info(f"[æ¨é€æ£€æŸ¥] æ£€æµ‹åˆ° {len(subscriptions)} æ¡è®¢é˜…")
                    for sub_key, _ in subscriptions:
                        user_id, tag = self.parse_key(sub_key)
                        push_key = f"{self.exist_subscribe_key}:{user_id}|{tag}"

                        if not await redis.exists(push_key):
                            logger.info(f"[æ¨é€ä¸­] æ¨é€æ¶ˆæ¯ç»™ç”¨æˆ· {user_id}ï¼Œæ ‡ç­¾ï¼š{tag}")
                            # TODO: å®é™…çš„æ¨é€é€»è¾‘
                            await redis.setex(push_key, self.push_interval_seconds, "1")

                await redis.aclose()
            except Exception as e:
                logger.error(f"[æ¨é€å¼‚å¸¸] {str(e)}")

            await asyncio.sleep(60)

    def parse_key(self, key):
        """è§£æè®¢é˜…é”® user:xxx|tag:xxx"""
        try:
            parts = key.split("|")
            user_id = parts[0].split(":")[1]
            tag = parts[1].split(":")[1]
            return user_id, tag
        except Exception as e:
            logger.error(f"è§£æ key å¤±è´¥: {key} -> {e}")
            return "", ""

if __name__ == "__main__":
    async def main():
        service = ScheduleService()
        await asyncio.gather(
            service.fixed_time_task(),
            service.check_redis_and_push(),
        )

    asyncio.run(main())

```

| **æ–¹æ¡ˆ** | **æ˜¯å¦å¼‚æ­¥** | **ä¼˜ç‚¹** | **ç¼ºç‚¹** | **æ¨èåœºæ™¯** |
| --- | --- | --- | --- | --- |
| ä¸Šè¿°è‡ªå®šä¹‰å†™æ³• | âœ… | çµæ´»ï¼ŒRedis ä»»åŠ¡é…åˆå¥½ | éœ€æ‰‹åŠ¨ç»´æŠ¤æ—¶é—´é€»è¾‘ | ä»»åŠ¡é‡å°‘ + redisè°ƒåº¦ç³»ç»Ÿ |
| schedule | âŒ | ç®€å•ã€æ˜“ç”¨ | ä¸æ”¯æŒå¼‚æ­¥ã€ä¸é€‚åˆæœåŠ¡éƒ¨ç½² | è„šæœ¬ç±»ã€ä¸€æ¬¡æ€§ä»»åŠ¡ |
| **APScheduler** | âœ… | æ”¯æŒå¼‚æ­¥ + cron/intervalï¼Œæ˜“ç»´æŠ¤ | åˆå­¦è€…éœ€è¦å­¦ä¹ ä¸‹è¯­æ³• | **æ¨èæœåŠ¡å¸¸é©»å‹åœºæ™¯** |

**æ”¯æŒå¼‚æ­¥â€**ï¼Œå°±æ˜¯æŒ‡åœ¨ä»»åŠ¡è°ƒåº¦å™¨ä¸­ï¼Œèƒ½ç›´æ¥è¿è¡Œè¿™ç§ï¼š

```python
async def job():
    # è¿™é‡Œå¯ä»¥æœ‰ awaitï¼Œä¾‹å¦‚æ“ä½œæ•°æ®åº“ã€è®¿é—® Redisã€å‘ HTTP è¯·æ±‚ç­‰
    await some_async_operation()
    print("å¼‚æ­¥ä»»åŠ¡å®Œæˆ")
```

è€Œ APScheduler çš„ AsyncIOScheduler ä¼šè®©ä½  **ä¸éœ€è¦ while True**ï¼Œä½ åªè¦æ³¨å†Œä¸€æ¬¡ job å‡½æ•°ï¼Œå®ƒä¼šè‡ªåŠ¨åœ¨å¯¹åº”æ—¶é—´ç‚¹è°ƒåº¦ã€æ”¯æŒå¹¶å‘ã€æ”¯æŒå¼‚æ­¥ã€æ”¯æŒ cron ç­‰å¤æ‚é€»è¾‘ï¼Œä¾‹å¦‚ï¼š

```python
from apscheduler.schedulers.asyncio import AsyncIOScheduler

async def job():
    await do_something_async()

scheduler = AsyncIOScheduler()
scheduler.add_job(job, 'interval', seconds=10)
scheduler.start()
```

è¿™ä¸ª wrapper() æ˜¯æ™®é€šå‡½æ•°ï¼Œapscheduler å°±å¯ä»¥è°ƒåº¦å®ƒï¼Œè€Œå®ƒå†…éƒ¨é€šè¿‡ asyncio.create_task() å¯åŠ¨äº†å¼‚æ­¥ä»»åŠ¡ã€‚