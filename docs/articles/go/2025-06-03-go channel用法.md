---
layout: post
title: "go channel 用法"
date: 2025-06-03
description: "go channel 用法"
tag: go
---   

# 介绍

**channel** 在 Go 中是一种**专门用来在 goroutine 之间传递数据**的**类型安全的管道**。

你可以把它理解成：

- 多个 goroutine 之间的**“传话筒”**，谁往通道里塞东西，另一个 goroutine 就能接收到。

Go 语言采用 **CSP（Communicating Sequential Processes）** 模型，也就是鼓励：

> 💡 “不要通过共享内存来通信，而要通过通信来共享内存”
> 

也就是通过 channel 来传递数据，而不是多个 goroutine 同时操作一份共享数据，这样能减少复杂的锁。

## **🧬 channel 的关键特性**

✅ **类型化**：

通道是有类型的，比如 chan int 只能传 int，chan string 只能传 string。

✅ **同步**：

默认情况下，不缓冲通道是**同步阻塞**：

- 发送方（ch `<- value）如果没人接收，就等着。
- 接收方（<- ch）如果没人发送，也等着。

✅ **缓冲区可选**：

你也可以给通道设置缓冲区，比如 make(chan int, 10)，这样最多能存 10 个 int，不满时发送方不会阻塞。

✅ **关闭通道**：

当通道关闭（close(ch)）后再接收，不会再阻塞，而是返回对应类型的零值和一个标志。

## **🎨 实际用法场景**

- **任务分发**：生产者 goroutine 往通道里传任务，消费者 goroutine 从通道取任务。
- **信号通知**：用通道只传递空 struct 来通知某个 goroutine 开始或结束工作。
- **并发控制**：限制 goroutine 数量，比如用缓冲通道当作信号量。

# go func()

```jsx
go func() {
    channel <- "Hello, World!"
}()
```

这里启动了**一个新的 goroutine** 来往通道中**发送数据**。

go func() { ... }() 相当于让任务**异步执行**，也就是你说的 Python 里的 create_task() 或者 await 背后的任务调度

当无缓冲通道必须一手给一手拿，所以你必须用 goroutine 来让另一个任务并行接收，否则就死锁。

假设你去掉 go func()，直接写成：

```jsx
channel := make(chan string)
channel <- "Hello, World!" // 直接发送
msg := <-channel
fmt.Println(msg)
```

那么这一行 channel <- "Hello, World!" 会**一直卡住**，因为：

- 这是无缓冲通道，必须**同时有接收方**（也就是 <- channel）在等着。
- 但是程序还没执行到接收方那一行，所以就死锁了。

用 go func() 把发送操作放到后台 goroutine 中，这样主 goroutine 可以**继续执行**接收逻辑，不再相互卡住。

换句话说：

- goroutine A：负责发送
- goroutine B：负责接收

如果没有 goroutine，把发送和接收写在一条顺序执行流里，就造成死锁。

**❓ 所有 channel 都必须这样写吗？**

**不必须**，取决于场景：

- 📌 如果你用**缓冲通道**，也就是：

```jsx
ch := make(chan string, 1)
ch <- "Hello"
msg := <-ch
```

- 有缓冲，所以发送完能直接存进去，不会阻塞，这时候也可以不用 goroutine。

• 📌 如果你的接收方先执行，比如：

```jsx
ch := make(chan string)
go func() {
    msg := <- ch
    fmt.Println(msg)
}()
ch <- "Hello"
```

>` 无缓冲通道要求
> 
> 
> **发送和接收必须成对并发执行**
> 

> 也可以用缓冲通道，这样中间能暂存数据，就不用 goroutine。
> 

# **无缓冲通道 vs 缓冲通道**

| **类别** | **定义** | **行为** |
| --- | --- | --- |
| 无缓冲通道 | ch := make(chan string) | 必须**一手交钱一手交货**（也就是**发送时必须有接收方正在等着**），否则发送方就堵住，不往下执行 |
| 有缓冲通道 | ch := make(chan string, N) | 通道内部有个缓冲区，当缓冲区没满时可以先把数据存起来，不需要接收方马上接收，发送方能继续往下走 |

**🔍 为什么无缓冲通道单线程会卡？**

无缓冲通道相当于是**零容量队列**，你要往里面塞东西，但是根本没有位置存，所以必须有人正在取，这时候才成对地完成操作。

你原来的例子：

```jsx
channel := make(chan string) // 无缓冲通道
channel <- "Hello" // <=== 这里堵住了
msg := <-channel
```

**为什么堵住？**

因为这一行执行时：

- 当前 goroutine 在这里卡住，等待另一个 goroutine 来接收数据。
- 但是你下一行还没执行，所以没有接收者！于是永远卡死。
- 🧑‍🤝‍🧑 **无缓冲通道**：必须当场给对方（必须有接收者正在等）。
- 📦 **有缓冲通道**：先放进快递柜（缓冲区），接收方可以迟点取。

用 Python 类比一下也许更清楚：

- 无缓冲通道就像你用 await queue.put()，但是**没有任何任务在取** → 任务永远卡在那里。
- goroutine 就像你用 create_task() 启动另一个任务负责 queue.get()，那么 put() 就能顺利执行完。

> 🔥 没缓冲通道：必须有接收方同时存在，否则卡死，所以你要用 goroutine 来接收。
> 

> 🔥 有缓冲通道：通道能先存东西，不必马上接收，所以可以顺利执行完发送，不用 goroutine。
> 

# **普通 int 变量与 channel 的区别**

| **对比点** | **普通** int **变量** | chan int **通道** |
| --- | --- | --- |
| 类型 | int 只存一个数字 | chan int 用来传送数字给别人 |
| 用法 | num := 42 然后用 num | ch := make(chan int) 然后用 ch <- 42 传数据 |
| 并发场景 | 只在**当前 goroutine**用 | 能在**多个 goroutine**之间传递数据，不共享状态 |
| 行为 | 单纯取值、赋值 | 发送必须有接收方，不然 goroutine 会等着 |
| 目的 | 存数据 | **让 goroutine 之间通信** |

**🎯 相当于什么现实场景？**

💡 想象你有两个工人：

1. 工人A（goroutine A）负责**生产东西**（例如生产一个数字）。
2. 工人B（goroutine B）负责**接收东西**然后打印出来。

那么：

- int num = 42 相当于是你自己手里拿着东西，没给任何人。
- channel <- 42 相当于是你**把东西放上传送带**，另一个工人能从传送带拿东西，这样两个人之间就实现协作啦。

你可以用共享变量，但是：

- 要加锁（防止读写冲突）。
- 要自己控制什么时候生产、什么时候消费，不然很可能出错。

用 channel 你就不用自己实现这些复杂逻辑，Go 会帮你：

✅ 发送数据时自动等待接收方。

✅ 接收数据时自动等待生产方。

✅ 并发安全，不用你加锁。